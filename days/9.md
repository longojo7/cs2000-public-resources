---
sidebar_position: 9
day_number: 9
title: Day 9 - Adding columns
---

## Skills: [1](</skills/#(1)>), [2](</skills/#(2)>)

## Pre-reading: [4.1.4.3](<%7B%7BDCIC_DOMAIN%7D%7D/intro-tabular-data.html#(part._.Adding_.New_.Columns)>), [4.1.4.4](<%7B%7BDCIC_DOMAIN%7D%7D/intro-tabular-data.html#(part._.Adding_.New_.Columns)>)

### Supplementary Videos

[Adding Columns](https://northeastern.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=581615fe-5cb1-478b-bcd8-b33f01284bbb)

## Reference: For all work with tables, refer to the [Tables](/tables) page in the menu at the top of the page!

## Intro (15 mins)

- Let's say we were designing a fantasy game, and had a table of items that were
  near the current player.
  ```pyret
    items = table: item :: String, x-coordinate :: Number, y-coordinate :: Number
      row: "Sword of Dawn",           23,  -87
      row: "Healing Potion",         -45,   12
      row: "Dragon Shield",           78,  -56
      row: "Magic Staff",             -9,   64
      row: "Elixir of Strength",      51,  -33
      row: "Cloak of Invisibility",  -66,    5
      row: "Ring of Fire",            38,  -92
      row: "Boots of Swiftness",     -17,   49
      row: "Amulet of Protection",    82,  -74
      row: "Orb of Wisdom",          -29,  -21
    end
  ```
- If we wanted to know the distance from the player to each item because, for
  example, if the distance were below a certain amount the player was able to
  pick the item up, we might want to add a new column, to create a table with
  four columns. We can do this using `build-column`.
- First, we need a function that takes a row and calculates the value for the
  new column. This function will be called once for _every row in the table_. But since the numbers we are producing are usually not exact,
  we need to use a different comparison operator for our tests, `is-roughly`. If you recall from [Day 1](/days/1), Pyret distinguishes between exact numbers (those that can be represented as fractions, precisely), and "rough" numbers, which can only be represented approximately. Since square root may return a number that cannot be represented exactly (the square root of 2 is a good example!, in order to have a consistent _type_, `num-sqrt` always returns a `RoughNum`, even in cases when an `ExactNum` could have been returned. Note that if you want to `order-by`, you need to convert it to an `ExactNum` with `num-to-rational`.
  ```pyret
  fun calc-distance(r :: Row) -> Number:
    doc: "does distance to origin from fields 'x-coordinate' and 'y-coordinate'"
    num-sqrt(num-sqr(r["x-coordinate"]) + num-sqr(r["y-coordinate"]))
  where:
    calc-distance(items.row-n(0)) is-roughly num-sqrt(num-sqr(23) + num-sqr(-87))
    calc-distance(items.row-n(3)) is-roughly num-sqrt(num-sqr(-9) + num-sqr(64))
  end
  ```
- Now we can add a column to create a new table:
  ```pyret
  items-with-dist = build-column(items, "distance", calc-distance)
  ```
- Let's say, instead, we wanted to move the player one unit of distance in the increasing
  `x` direction. This would mean that the origin shifts by 1, and so the
  `x-coordinate` field in the table should have 1 subtracted from it, since
  items that were to the right are now closer, and the left ones (the negative
  coordinates) are now further.
- We can do this by using `transform-column`, which takes a function that
  transforms a single column, here the value of the `x-coordinate`. So let's
  write one:
  ```pyret
  fun subtract-1(n :: Number) -> Number:
    doc: "subtracts 1 from input"
    n - 1
  where:
    subtract-1(10) is 9
    subtract-1(0) is -1
    subtract-1(-3.5) is -4.5
  end
  ```
- Now we can construct a shifted table:
  ```pyret
  moved-items = transform-column(items, "x-coordinate", subtract-1)
  ```

## Class Exercise (40 mins)

1. Imagine all the items were pulled closer to the player by scaling both the x and y coordinates down by 10% (this doesn't make the distance 10% less, but is simpler). Create a new table that has
   new x & y coordinates for all the items.
2. Extract the name of the item that is closest to the player. Note that if you want to `order-by`, you need to convert it to an `ExactNum` with `num-to-rational`.
3. You want to "obfuscate" the list of items, displaying, rather than the name, a
   string that is a sequence of "X"s of the same length. i.e., "Sword of Dawn"
   becomes `"XXXXXXXXXXXXX"`. Create a new table that is so transformed.
4. Get a dataset from the [City of Boston Employee Earnings Report](https://data.boston.gov/dataset/employee-earnings-report), and load it via the CSV url.
5. Calculate the total earnings _excluding_ the "DETAIL" column, since that is _private_
   compensation (police & fire employees hired for private events). You might notice, in doing this, that the columns are not numbers, they are strings! With commas! Furthermore, some of the data has no values for certain rows which are loaded as empty strings `""`. The commas and empty strings mean our normal strategy of using `sanitize using num-sanitizer` won't work, and while we will talk more
   about data cleaning next time for now you can use `transform-column`, using the helper function:
   ```pyret
   fun string-to-number-unsafe(s :: String) -> Number:
     doc: "Converts the given string to a number, returning 0 if not well formatted"
     string-to-number(string-replace(s, ",", "")).or-else(0)
   where:
     string-to-number-unsafe("1234") is 1234
     string-to-number-unsafe("-1.3") is -1.3
     string-to-number-unsafe("hello") is 0
   end
   ```
6. Now sort by your new total compensation to see the highest paid employees in
   the city. Sort the other way to see who is the lowest paid.

## Wrap-up (5 mins)

- Transforming data is key to programming with tables. The original source of
  data may not have what you need in the right format, but we can use operations
  like `build-column` or `transform-column` to create new tables that do.
